procedure alloc_temp(int tmpo, stack tmp_stack)
    //tmp_sp += 1
    push(tmpo,tmp_stack)
   //mp_stack[tmp_sp] += 0


procedure gaussian_elim(int mat[], int inv[], int dim, stack zero)
    local int i = 0
    from i = 0 loop
        local int j = 0
        from j = 0 loop
            if mat[j*(dim-1)+i] != 0 then
                local int row_multiplier = mat[i*(dim-1)+j]/mat[j*(dim-1)+i]
                //call alloc_temp(row_multiplier, zero)
                local int k = 0
                from k = 0 loop
                    mat[i*(dim-1)+k] -= mat[j*(dim-1)+k]*row_multiplier
                    inv[i*(dim-1)+k] -= mat[j*(dim-1)+k]*row_multiplier
                    k += 1
                until k = dim
                delocal int k = dim
                call alloc_temp(row_multiplier, zero)
                delocal int row_multiplier
            fi mat[j*(dim-1)+j] = 1
            j += 1
        until j = i
        local int reducing_multiplier = mat[i*(dim-1)+i]

        if reducing_multiplier != 0 
            then local int k = 0
                k += i
                from k = i loop
                    local int holder1 = mat[i*(dim-1)+k]
                    local int holder2 = inv[i*(dim-1)+k]
                    //call alloc_temp(holder1, zero)
                    //call alloc_temp(holder2, zero)

                    
                    mat[i*(dim-1)+k] -= holder1
                    mat[i*(dim-1)+k] += holder1/reducing_multiplier
                    
                    inv[i*(dim-1)+k] -= holder2
                    inv[i*(dim-1)+k] += mat[i*(dim-1)+k]/reducing_multiplier
                    
                    call alloc_temp(holder2, zero)
                    call alloc_temp(holder1, zero)
                    
                    delocal int holder2
                    delocal int holder1
                    k += 1
                until k = dim
                k -= dim
                delocal int k = 0
        fi reducing_multiplier != 0 
        call alloc_temp(reducing_multiplier, zero)
        delocal int reducing_multiplier
        j -= i
        delocal int j = 0
        i += 1
    until i = dim
    delocal int i = dim
    
    local int i = dim - 1 
    from i = dim - 1 loop
        local int j = i
        from j = i loop
            local int row_multiplier = mat[i*(dim-1)+j]
            //call alloc_temp(row_multiplier, zero)
            local int k = 0
            from k = 0 loop
                local int holder1 = mat[j*(dim-1)+k]

                mat[i*(dim-1)+k] -= holder1*row_multiplier
                inv[i*(dim-1)+k] -= holder1*row_multiplier
                call alloc_temp(holder1, zero)
                delocal int holder1

                k += 1
            until k = dim
            k -= dim
            delocal int k = 0
            call alloc_temp(row_multiplier, zero)
            delocal int row_multiplier

            j += 1
        until j = dim - 1
        j -= dim - 1
        j += i
        delocal int j = i
        i -= 1    
    until i = 0
    i += dim - 1

    delocal int i = dim - 1
    






procedure id(int inv[], int dim)
    local int k = 1
    inv[0] += 1
    inv[dim**2-1] += 1
    from k = 1 loop
        inv[dim*k+k] += 1
        k += 1
    until k = dim-1
    k -= dim-1
    k += 1
    delocal int k = 1


procedure main()
    //n = number of rows
    //m = number of columns
    //matrices are converted to 1D arrays by reading out each element of a row, then moving to the next one
    //(left to right)
    int dim = 2

    int mat[dim**2]
    int inv[dim**2]

    stack zero
    // have to select matrix where det is 1
    //int only, can't do Gaussian elimination like this
    //divide by 0 error, have to do safety check
    //floating point numbers are inherently reversible
    mat[0] += 1 
    mat[1] += 1 
    mat[2] += 4
    mat[3] += 3
    //mat[4] += 1
    //mat[5] += 0
    //mat[6] += 0
    //mat[7] += 0
    //mat[8] += 1


    //sets inverse to identity to begin process
    call id(inv, dim)
    call gaussian_elim(mat,  inv, dim, zero)
